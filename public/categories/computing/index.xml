<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>computing on lost in economics</title>
    <link>/categories/computing/index.xml</link>
    <description>Recent content in computing on lost in economics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/computing/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>My Stupid Git Experience</title>
      <link>/note/2017/10/20/my-stupid-git-experience/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/10/20/my-stupid-git-experience/</guid>
      <description>&lt;div id=&#34;disclaimer&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;이 문서는 &lt;code&gt;git&lt;/code&gt;을 다루면서 저질렀던 개인적을 실수를 모아 놓은 것이다. 아마도 문서 자체가 조금씩 진화할 것이므로 어떤 시점에서 보신다면 몹시 허접할 수 있도 있겠다. git에 대해서 잘 아는 분들은 패스하시라.&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-structure&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic structure&lt;/h1&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/dr_structure.png&#34; /&gt;

&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;working dir&lt;/code&gt;: local의 작업디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;: staging area. 커밋될 파일들을 올려 두는 공간&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;: 최후의 커밋&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-command&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic command&lt;/h1&gt;
&lt;div id=&#34;initiation-in-local&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Initiation in local&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;로컬머신에서 git을 개시하는 방법부터 알아보자.&lt;/li&gt;
&lt;li&gt;git으로 관리하고 싶은 directory에서 아래와 같은 명령어를 쳐 준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;echo &amp;quot;# YOUR_README_NAME&amp;quot; &amp;gt;&amp;gt; README.md 
git init
git add README.md 
git commit -m &amp;quot;YOUR_COMMIT_MESSAGE/first commit&amp;quot;
git remote add origin &amp;lt;&amp;lt;https://YOUR_REMOTE_GIT_URL&amp;gt;&amp;gt;
git push -u origin master &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;https://YOUR_REMOTE_GIT_URL&amp;gt;&amp;gt;&lt;/code&gt;: 외부 리포가 적절하게 세팅이 되어 있어야 한다. github를 쓴다면, readme 없이 새 repository를 터주는 작업 만으로 끝이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo...&lt;/code&gt;: “# YOUR_README_NAME” 내용을 &lt;code&gt;README.md&lt;/code&gt;로 생성한 후&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;: 해당 디렉토리에 git을 개시한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote add&lt;/code&gt;: git의 remote 저장소를 &lt;code&gt;origin&lt;/code&gt;이라는 이름으로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;: &lt;code&gt;-u&lt;/code&gt;는 업스트림 브랜치를 master로 기본설정해준다. 이후 &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;은 자동으로 &lt;code&gt;origin &amp;lt;-&amp;gt; master&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;add-commit-push&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git status  
git add .
#or
git add -u
git commit -m &amp;quot;YOUR_COMMENT&amp;quot;
git push &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;git 운용의 기본적인 흐름 혹은 기본 셋&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt;만 명령하면 되는 것은 앞서 &lt;code&gt;git push -u origin master&lt;/code&gt; origin master로 local과 remote repository의 upstream을 정해두었기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;in-depth-command&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;In-depth command&lt;/h1&gt;
&lt;div id=&#34;remote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git remote  

origin 

&amp;gt; git remote -v 

git status  
git add .
git commit -m &amp;quot;YOUR_COMMENT&amp;quot;
git push &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; : remote로 어떤 대상이 설정되어 있는지 볼 수 있다. &lt;code&gt;git remote -v&lt;/code&gt;: remote의 구체적인 내용을 조회해볼 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pull&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;pull&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pull&lt;/code&gt; 명령어는 기본적으로 &lt;code&gt;fetch&lt;/code&gt;(가져오기)와 &lt;code&gt;merge&lt;/code&gt;(병합하기)를 동시에 구현하는 것이다. 보통 &lt;code&gt;fetch&lt;/code&gt;는 repository의 내용을 가져와 &lt;code&gt;fetch_head&lt;/code&gt;라는 local branch에 임시로 저장해둔다. &lt;code&gt;merge&lt;/code&gt;는 이렇게 가져온 데이터를 원래 흐름과 병합하는 것이다. 이 둘을 동시에 구현하는 것이 &lt;code&gt;pull&lt;/code&gt;이다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;논리적으로 봤을 때, origin과 master에서 모두 변경 사항이 있을 경우는 둘에 충돌이 일어날 수 밖에 없다. 이런 경우 이 충돌을 해결해줘야 &lt;code&gt;push&lt;/code&gt;가 가능하다.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;깔끔한 이력 관리를 위해서는 아래와 같이 rebase를 활용해서 pull을 해주면 좋다. rebase를 해주면 별도의 브랜치를 만들지 않겠다는 의도를 분명히 하는 것이고, 이에 따라서 log가 깔끔하고 단순해진다.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git pull --rebase&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;commit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;commit&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;&amp;lt;&amp;lt;YOUR_MESSAGE&amp;gt;&amp;gt;&amp;quot;&lt;/code&gt;: 기본적인 문법&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;-commit-push---&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;이전 &lt;code&gt;commit-push&lt;/code&gt;된 버전을 수정하고 싶다면&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;뭔가를 수정했다. 하지만 새로운 commit을 만들고 싶지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend --no-edit&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--amend --no-edit&lt;/code&gt;: 전에 commit message를 그대로 쓰고 commit한다.&lt;/li&gt;
&lt;li&gt;문제는 이대로 push를 할 수 없다는 것이다. 앞서 push된 버전과 현 수정된 버전이 동일한 commit인데, 내용이 다르다. 즉, SHA-1이 다르다. 이때 강제로 &lt;code&gt;push&lt;/code&gt;를 하고 싶다면 아래와 같이 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git push -f [origin] [master]&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;: commit을 새로 만든 것이 아니기 때문에, 그대로 push를 하게 되면 origin과 맞지 않게 된다. 강제로 push를 해서 맞춰주는 명령어다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;branch&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;branch&lt;/code&gt;&lt;/h1&gt;
&lt;div id=&#34;basic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Basic&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git branch &amp;lt;BRANCH_NAME&amp;gt;
git checkout
git checkout -b &amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt;: 브랜치를 조회하거나, &lt;code&gt;&amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;을 붙여 브랜치를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkout&lt;/code&gt;이란 다른 브랜치로 빠져나가는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt;: 브랜치를 만들면서 체크아웃을 하기 위해서는 이 옵션을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git merge &amp;lt;COMMIT_NAME&amp;gt; 
git branch -d &amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;: 커밋된 다른 지점과 현재 브랜치를 병합한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;: 브랜치를 삭제하기 위해서 사용하는 명령어&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;conflict&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;conflict&lt;/h2&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/conflict.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge issue3&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;이때 어떤 파일에 대해서 master의 내용과 issue의 내용이 서로 다른 부분이 있다고 하자.&lt;/li&gt;
&lt;li&gt;병합이 무리 없이 가능하다면 그대로 병합한다. 즉, A와 B가 있을 떄 B가 A의 내용을 포함하고 있다면, 병합이 가능하다.&lt;/li&gt;
&lt;li&gt;파일 자체가 다른 경우는 인간의 판단이 필요하다. 해당 파일을 열면 아래와 같이 표현되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;원숭이도 이해할 수 있는 Git 명령어
add: 변경 사항을 만들어서 인덱스에 등록해보기
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
commit: 인덱스의 상태를 기록하기
=======
pull: 원격 저장소의 내용을 가져오기
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; issue3&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/code&gt;는 &lt;code&gt;====&lt;/code&gt;까지 HEAD의 부분이고, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; issue3&lt;/code&gt;의 부분이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;rebase&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;rebase&lt;/code&gt;&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;특정한 브랜치를 다른 브랜치로 합친 후에 이전 브랜치는 없애고 싶을 때, 한번에 처리하는 명령어가 rebase다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;원래 상태는 HEAD를 master로 하고 브랜치는 다음과 같이 3가지다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout issue3
git rebase master &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;issue3로 체크아웃을 한 뒤에 해당 브랜치를 master로 rebase한다. 만일 두 노드 사이에 충돌이 없다면 rebase가 되곘지만, 충돌이 있을 경우에는 해당 파일을 수정해줘야 한다. 수정 후 아래와 같이 rebase한다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_2.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;git add myfile.txt 
git rebase --continue &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_3.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;git checkout master 
git merge issue3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;master&lt;/code&gt;로 체크아웃한 이후에 issue3 merge하면 아래와 같이 가지가 정리된다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_4.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;branch-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;branch&lt;/code&gt;&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://backlog.com/git-tutorial/kr/stepup/stepup2_1.html&#34; class=&#34;uri&#34;&gt;https://backlog.com/git-tutorial/kr/stepup/stepup2_1.html&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;case-by-case&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Case by case&lt;/h1&gt;
&lt;div id=&#34;github---local---&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Github의 내용을 강제로 local로 덮어쓰고 싶을 때&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;그냥 지우고 다시 clone을 할 수도 있다. 혹은&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git fetch --all
git reset --hard origin/master
git pull origin master&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;local----github---&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;local에 있는 내용을 강제로 github으로 보내고 싶을 때&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git pull --rebase
git push
git stash pop&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;miscellaneous&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Miscellaneous&lt;/h1&gt;
&lt;div id=&#34;gitignore&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;.gitignore&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;vim으로 만들 수도 있다. 물론, txt editor로 만들어도 무방하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;vim .gitignore &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;vim 화면 위쪽에 입력하려면 i(insert)를 치고, 제외할 타잎을 넣는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;*.Rhistory 
*.RData &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;ESC를 치면 화면 아래 command 창으로 이동한다. :qw(quit &amp;amp; write)를 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;homework&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Homework&lt;/h1&gt;
&lt;div id=&#34;log&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;log&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git log --pretty=oneline&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%BB%A4%EB%B0%8B-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0&#34;&gt;링크&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;other-link&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Other link&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://meetup.toast.com/posts/116&#34; class=&#34;uri&#34;&gt;http://meetup.toast.com/posts/116&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>