<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on lost in economics</title>
    <link>/note/index.xml</link>
    <description>Recent content in Notes on lost in economics</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Nov 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/note/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Use your font</title>
      <link>/note/2017/11/16/use-your-font/</link>
      <pubDate>Thu, 16 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/11/16/use-your-font/</guid>
      <description>&lt;style&gt;
pre.bluebox {
    background-color: #aabbff !important;
}
pre.redbox {
    background-color: #ffbbbb !important;
}
&lt;/style&gt;
&lt;div id=&#34;non-alphabetical&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Non-alphabetical&lt;/h1&gt;
&lt;p&gt;폰트 문제는 쉬운 듯 어려운 문제다. 그냥 OS에서 폰트 깔아서 쓰듯 쓸 수 있으면 좋으련만 ‘그렇게’ 쉽게 쓸 수는 없다. R에서 그래프를 그려본 사람이라면, 어 “왜 (그래프에서) 폰트가 네모박스로 나와”하는 상황을 한번은 마주쳐 봤을 것이다. 이는 R과 RStudio가 OS에서 끌어다 쓰는 부분이 제한적이기 때문에 생기는 일이다. 그렇다고 못생긴 굴림체와 계속 살 수는 없는 노릇이니 방법을 찾긴 해야 한다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extrafont-showtext&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;extrafont? showtext!&lt;/h1&gt;
&lt;p&gt;언제나 그렇듯이 구글 검색을 해보면 extrafont 패키지가 주로 검색된다.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 이 패키지는 로컬 머신에 설치된 폰트를 끌어다가 그림에 심는 것을 구현한다. 다만 이 경우 로컬 머신을 오가며 작업할 경우 폰트 사용을 일관되게 하기 곤란해질 수 있다. 아울러 패키지가 트루타입(ttf)만 지원하기 때문에 폰트 이용 자체에도 다소 한계가 있다.&lt;/p&gt;
&lt;p&gt;Yixuan Qiu가 개발한 showtext는 보다 일관된 폰트 사용을 목표로 한다. 우선 이 패키지를 쓰면 폰트를 꼭 시스템에 미리 설치해 둘 필요가 없다. 설치되지 않은 폰트도 파일의 경로만 지정해주면 그래프 등의 시각 결과물에서 해당 폰트를 잘 구현해준다. 아울러 TrueType, OpenType, Type 1, web font 등 다양한 포맷을 지원한다. 구글에서 제공하는 폰트의 경우에는 파일 경로로 필요 없다. 이름만 지정해주면 온라인에서 다운로드 받아서 알아서 구현한다. 물론 구글 폰트 데이터베이스에 등재된 한글 폰트가 없다는 것이 살짝 아쉬운 대목이다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;basic&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#### Start of testing code 
library(tidyverse)
library(showtext)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://fonts.google.com/&#34;&gt;구글&lt;/a&gt;에 등록된 폰트는 쉽게 불러올 수 있다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_add_google(&amp;quot;Gochi Hand&amp;quot;, &amp;quot;gochi&amp;quot;)
font_add_google(&amp;quot;Schoolbell&amp;quot;, &amp;quot;bell&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 호출하면 구글 리포지터리에서 폰트를 불러와 설정한다. 1번 인자가 구글의 fullname이고 2번 인자가 내가 코드에서 호출할 이름이다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;showtext_auto()

#windows() # if your local os is Windows 
# x11() # if your local os is Macos 

set.seed(123)
hist(rnorm(1000), breaks = 30, col = &amp;quot;steelblue&amp;quot;, border = &amp;quot;white&amp;quot;,
     main = &amp;quot;&amp;quot;, xlab = &amp;quot;&amp;quot;, ylab = &amp;quot;&amp;quot;)
title(&amp;quot;Histogram of Normal Random Numbers&amp;quot;, family = &amp;quot;bell&amp;quot;, cex.main = 2)
title(ylab = &amp;quot;Frequency&amp;quot;, family = &amp;quot;gochi&amp;quot;, cex.lab = 2)
text(2, 70, &amp;quot;N = 1000&amp;quot;, family = &amp;quot;bell&amp;quot;, cex = 2.5)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/note/2017-11-16-myfont_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;안타깝지만 RStudio의 기본 그래픽 장치는 showtext와 호환되지 않는다. 즉, RStudio 화면 우측 하단에는 폰트가 위의 그림처럼 표현되지 않는다. 당황하지 말자. 그냥 명령어로 별도의 그래픽 장치를 호출하면 된다. Windows라면 &lt;code&gt;windows()&lt;/code&gt;를, Macos라면 &lt;code&gt;x11()&lt;/code&gt;을 적절한 위치에 넣어주자. 이 문서가 작성된 rmarkdown에서도 폰트가 제대로 표현되지 않는다. 이때 코드 옵션에 &lt;code&gt;fig.showtext=TRUE&lt;/code&gt;를 추가하면 위의 그림처럼 잘 나온다. 즉, 마크다운 코드 옵션의 윗단을 아래와 같이 적절하게 처리해주면 되겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{R message=FALSE, warning=FALSE, fig.showtext=TRUE}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그림 출력 상태를 온오프 하기 위해서는 &lt;code&gt;showtext_auto()&lt;/code&gt;로 자동화할 수도 있고, &lt;code&gt;showtext_begin()&lt;/code&gt;, &lt;code&gt;showtext_end()&lt;/code&gt;로 미세조정을 추구할 수도 있다.&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;what-about-korean-font&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What about Korean font?&lt;/h1&gt;
&lt;p&gt;앞서도 이야기 했지만 Google fonts에는 안타깝게도 한글이 없다. early access에는 10종 정도가 포함되어 있지만 정식 리포지터리에는 없으므로 &lt;code&gt;font_add_google()&lt;/code&gt;로는 한글을 구현할 수 없다. 이 경우 적절한 위치에 폰트 원본 파일을 놓고 이를 불러오면 된다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_add(family = &amp;quot;hwhitecat&amp;quot;, regular = &amp;quot;fonts/HoonWhitecatR.ttf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위의 코드는 현재 디렉토리의 하위에 위치한 &lt;code&gt;fonts/HoonWhitecatR.ttf&lt;/code&gt; 폰트를 “hwitecat”이라는 패밀리의 레귤러로 심어준다. 레귤러, 이탤릭, 볼드 등을 따로 따로 지정할 수도 있다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;font_add(&amp;quot;constan&amp;quot;, regular = &amp;quot;fonts/constan.ttf&amp;quot;, italic = &amp;quot;fonts/constani.ttf&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;showtext_auto()

p = ggplot(NULL, aes(x = 1, y = 1)) + ylim(0.8, 1.2) +
  theme(axis.title = element_blank(), axis.ticks = element_blank(),
        axis.text = element_blank()) +
  annotate(&amp;quot;text&amp;quot;, 1, 1.1, family = &amp;quot;hwhitecat&amp;quot;, size = 17,
           label = &amp;quot;안녕, 세상아! 나는 흰고양체야.&amp;quot;) + 
  annotate(&amp;quot;text&amp;quot;, 1, 1, family = &amp;quot;heiti&amp;quot;, size = 15,
           label = &amp;quot;\u4F60\u597D\uFF0C\u4E16\u754C&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, 1, 0.9, label = &amp;#39;Chinese for &amp;quot;Hello, world!&amp;quot;&amp;#39;,
           family = &amp;quot;constan&amp;quot;, fontface = &amp;quot;italic&amp;quot;, size = 12)

print(p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/note/2017-11-16-myfont_files/figure-html/unnamed-chunk-6-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;언제나 그렇지만 너무 많은 서체를 쓰는 것은 (단연코!) 보기 좋지 않다. 단정하게 그냥 나눔고딕 혹은 Noto Sans CJK KR 정도로 만족하면 어떨까?&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;digression-how-to-generate-and-save-graphs&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Digression: How to generate and save graphs&lt;/h1&gt;
&lt;p&gt;혹시나 하는 마음에서 부록 하나 덧붙여 본다. R도 그렇지만 대개의 오픈소스 소프트웨어들은 그림을 만들 때 “장치”를 사용해서 만든다. 그래픽을 생성해 출력하는 장치라고 보면 되고, 스크린, pdf, png 등등 여러가지 형태를 지닌다. 일반적으로 OS 상에서 화면에 있는 그림을 캡쳐해서 포맷에 맞게 저장하는 식으로 생각하지 말고, 필요한 그림은 장치를 통해 생성한다고 이해하면 쉽다.&lt;/p&gt;
&lt;p&gt;바로 위에 예를 RStudio에 그대로 복붙했다면, 출력물 &lt;code&gt;p&lt;/code&gt;에서 폰트를 제대로 볼 수 없었을 것이다. 앞서도 말했지만, RStudio의 기본 화면 장치는 showtext를 아직 지원하지 않는다. 아래 처럼 해야 제대로 출력된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;windows()  # if your local os is Windows 
# x11() # if your local os is Macos 
print(p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기까지 실행하면 화면에 팝업으로 출력물이 뜨게 된다. PDF로 저장하기 위해서는 PDF 장치를 부르면 된다. 이때 &lt;code&gt;dev.off()&lt;/code&gt;를 지정해줘야 pdf 저장이 완료된다는 점 명심하자. 화면 팝업은 수동으로 창을 끄면 &lt;code&gt;dev.off()&lt;/code&gt;가 되지만 파일은 그렇지 않다. 반드시 &lt;code&gt;dev.off()&lt;/code&gt;를 넣어줘야 파일을 쓰게 된다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pdf(&amp;quot;YOUR_FILENAME.pdf&amp;quot;, width = 7, height = 4) 
print(p) 
dev.off()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이게 귀찮다면 ggplot2 패키지를 쓰자. ggplot2는 장치를 포맷 별로 편리하게 기록할 수 있는 통일적인 방법을 제공한다. &lt;code&gt;ggsave&lt;/code&gt; 명령어를 쓰면 &lt;code&gt;dev.off()&lt;/code&gt;없이 대부분의 포맷으로 아래와 같이 편리하게 저장할 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ggsave(&amp;quot;YOUR_FILENAME.pdf&amp;quot;, p, width = 7, height = 4)
ggsave(&amp;quot;YOUR_FILENAME.png&amp;quot;, p, width = 7, height = 4, dpi = 96)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://freesearch.pe.kr/archives/3138&#34;&gt;여기&lt;/a&gt;를 참고하라.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;자세한 것은 &lt;a href=&#34;https://cran.rstudio.com/web/packages/showtext/vignettes/introduction.html&#34;&gt;여기&lt;/a&gt;를 참고하라.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Magrittr - Ceci n&#39;est pas un pipe.</title>
      <link>/note/2017/11/15/magrittr---ceci-nest-pas-un-pipe./</link>
      <pubDate>Wed, 15 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/11/15/magrittr---ceci-nest-pas-un-pipe./</guid>
      <description>&lt;style&gt;
pre.bluebox {
    background-color: #aabbff !important;
}
pre.redbox {
    background-color: #ffbbbb !important;
}
&lt;/style&gt;
&lt;div id=&#34;magritt&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Magritt?&lt;/h1&gt;
&lt;center&gt;
&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/en/b/b9/MagrittePipe.jpg&#34; /&gt; &lt;span class=&#34;math inline&#34;&gt;\(~~\)&lt;/span&gt; &lt;img src=&#34;https://www.rstudio.com/wp-content/uploads/2014/04/magrittr-200x232.png&#34; /&gt;
&lt;/center&gt;
&lt;p&gt;magrittr, R 패키지 중에서 아마도 가장 재미있는 이름이 아닐까? 왜 마그리뜨일까? magrittr 패키지는 명령어 처리를 쭉 이어줄 수 있게 해준다. 즉, 파이프라인(pipeline)을 만들어주는 것이다. 이걸 파이프 담배와 연결시켜 “이것은 파이프가 아니다”라는 마그리뜨의 그림까지 연결된다. 우리가 만드는 것은 파이프라인이니 magrittr은 정말로 파이프는 아니다!&lt;/p&gt;
&lt;p&gt;이렇게 쭉 연결하는 것이 왜 좋을까? 글은 만연체가 좋지 않지만, 코딩에서 이렇게 파이프라인을 만드는 습관은 (황당할 정도로 길지 않은 이상) 일관된 형태의 작업을 가능하게 해준다. 물 흐르듯 흐르며 코딩한다, 라는 느낌을 떠올리면 좋겠다. 아울러 블필요한 data.frame이나 기타 오브젝트를 만들지 않아도 된다. 거두 절미하고 일단 패키지부터 태우자.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#devtools::install_github(&amp;quot;smbache/magrittr&amp;quot;) # if lastest release is needed
library(&amp;#39;tidyverse&amp;#39;)
library(&amp;#39;magrittr&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;basic&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic&lt;/h1&gt;
&lt;p&gt;magrittr 파이프라이닝 기본 원칙은 앞에서 주어진 혹은 계산된 결과가 뒤에 오는 명령어의 첫번째 인자argument로 들어가는 것이다. 즉, 좌변(lhs)의 내용을 우변(rhs)의 최초 인자로 던져주는 것이라고 보면 된다. 예를 보는 편이 빠르겠다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;% head(10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;앞서의 내용은 보통 &lt;code&gt;head(iris, 10)&lt;/code&gt;라고 쓴다. 파이프라이닝은 두가지로 도움이 된다. 말의 어순을 떠올리면 좋겠다. “&lt;code&gt;iris&lt;/code&gt;라는 데이터의 앞쪽 10개를 출력해.” 앞서의 명령을 말로 할 수 있다면 이렇게 말할 것이다. 하지만, 코딩은 “앞쪽의 &lt;code&gt;iris&lt;/code&gt;의 10개” 이런 식으로 하고 있다. 뭔가 버벅대는 느낌 아닌가? &lt;code&gt;()&lt;/code&gt;를 쓰게 되면 적용할 명령(함수)을 먼저 생각하고 이후에 적용 대상(데이터, 변수, 객체 등등)을 생각하게 된다. 말로 하는 명령처럼 코딩하는게 보다 편리하지 않을까? 데이터를 먼저 생각하고 여기 적용할 방법을 따지는 게 생각 혹은 작업의 흐름상 자연스럽다. 두번째, 디버깅을 해본 분들을 알겠지만, &lt;code&gt;()&lt;/code&gt;가 계속 이어질 경우 열림 괄호와 닫힘 괄호를 잘못 쓸 가능성이 생각보다 높다. magrittr을 이용하면 이런 귀찮은 문제가 최소화된다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;where-to-put-argument&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Where to put argument&lt;/h1&gt;
&lt;p&gt;파이프라인에서 lhs에 있는 것은 뒤 명령어의 첫번째 인자로만 적용되어야 할까? 만일 &lt;code&gt;x %&amp;gt;% f(y,x)&lt;/code&gt;라는 스타일로 적용하고 싶다면? 물론 가능하다. 이떄는 닷(&lt;code&gt;.&lt;/code&gt;)을 사용할 수 있다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;10 %&amp;gt;% head(iris, .)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species
## 1           5.1         3.5          1.4         0.2  setosa
## 2           4.9         3.0          1.4         0.2  setosa
## 3           4.7         3.2          1.3         0.2  setosa
## 4           4.6         3.1          1.5         0.2  setosa
## 5           5.0         3.6          1.4         0.2  setosa
## 6           5.4         3.9          1.7         0.4  setosa
## 7           4.6         3.4          1.4         0.3  setosa
## 8           5.0         3.4          1.5         0.2  setosa
## 9           4.4         2.9          1.4         0.2  setosa
## 10          4.9         3.1          1.5         0.1  setosa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;여기서 주의할 사항 하나 짚고 가겠다. 닷(&lt;code&gt;.&lt;/code&gt;)을 지정할 때 앞의 예처럼 단순한 형태면 상관없다. 다만, 닷(&lt;code&gt;.&lt;/code&gt;)이 다른 또다른 명령에 앞뒤로 다시 걸치게 되면 (영어로 하면 nested), 원래 형태 즉 lhs가 첫번째 인자로 강제 인식된다. 이점을 이해하지 못하면 이해할 수 없는 에러와 마주치거나 잘못된 결과를 얻게 된다. 내가 이걸 몰라서 낭비한 시간을 떠올리면 눈물이 앞을 가린다. 두가지 사례를 보자. 숫자가 주어졌을 때, 이에 해당하는 순서의 알파벳을 찾는 것이 목적이다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sample(1:10) %&amp;gt;% paste0(LETTERS[.])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;7G&amp;quot;  &amp;quot;10J&amp;quot; &amp;quot;9I&amp;quot;  &amp;quot;2B&amp;quot;  &amp;quot;3C&amp;quot;  &amp;quot;4D&amp;quot;  &amp;quot;6F&amp;quot;  &amp;quot;8H&amp;quot;  &amp;quot;1A&amp;quot;  &amp;quot;5E&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보는 바대로 숫자에 알파벳이 따라 붙었어 있다. 이는 &lt;code&gt;.&lt;/code&gt;이 &lt;code&gt;LETTERS&lt;/code&gt;의 인자로 활용되었기 때문이다. 그래서, lhs의 인자를 최초의 투입으로 보고 위와 같은 결과를 만든 것이다. 내가 원하는 결과물이 아니다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sample(1:10) %&amp;gt;% { paste0(LETTERS[.]) } &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;H&amp;quot; &amp;quot;C&amp;quot; &amp;quot;D&amp;quot; &amp;quot;J&amp;quot; &amp;quot;F&amp;quot; &amp;quot;B&amp;quot; &amp;quot;E&amp;quot; &amp;quot;I&amp;quot; &amp;quot;A&amp;quot; &amp;quot;G&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다른 예를 하나 더 보자.&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tibble(
  type = c(&amp;quot;Fast&amp;quot;, &amp;quot;Slow&amp;quot;, &amp;quot;Fast&amp;quot;, &amp;quot;Fast&amp;quot;, &amp;quot;Slow&amp;quot;),
  colour = c(&amp;quot;Blue&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Red&amp;quot;, &amp;quot;Red&amp;quot;, &amp;quot;Red&amp;quot;)
) %&amp;gt;% table(.$type, .$colour)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;redbox&#34;&gt;&lt;code&gt;Error in sort.list(y) : &amp;#39;x&amp;#39; must be atomic for &amp;#39;sort.list&amp;#39; Have you called &amp;#39;sort&amp;#39; on a list?&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뭐가 잘못되었을까? rhs에 들어간 &lt;code&gt;.&lt;/code&gt;은 &lt;code&gt;.$type&lt;/code&gt;, &lt;code&gt;.$colour&lt;/code&gt; 식으로 다른 명령어로 자신을 넘긴다. 이 경우는 lhs가 table의 첫번째 인자로 인식된다. &lt;code&gt;table(x, x$type, x$colour)&lt;/code&gt;가 되어 에러를 유발한다. 이를 해결하기 위해서는 파이프를 끊거나 아니면 &lt;code&gt;{}&lt;/code&gt;를 해주면 된다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tibble(
  type = c(&amp;quot;Fast&amp;quot;, &amp;quot;Slow&amp;quot;, &amp;quot;Fast&amp;quot;, &amp;quot;Fast&amp;quot;, &amp;quot;Slow&amp;quot;),
  colour = c(&amp;quot;Blue&amp;quot;, &amp;quot;Blue&amp;quot;, &amp;quot;Red&amp;quot;, &amp;quot;Red&amp;quot;, &amp;quot;Red&amp;quot;)
) %&amp;gt;% { table(.$type, .$colour) }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       
##        Blue Red
##   Fast    1   2
##   Slow    1   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{}&lt;/code&gt;로 감싸는 진짜 의미는 사실 lhs의 인자를 받아서 새롭게 함수를 구성하라는 것이다. 때문에 더 복잡한 형태로 구성할 수도 있다. magrittr에서는 이를 “lambda expression”이라 부른다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;% 
{
  size &amp;lt;- sample(1:10, size = 1)
  rbind(head(., size), tail(., size))
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
## 1            5.1         3.5          1.4         0.2    setosa
## 150          5.9         3.0          5.1         1.8 virginica&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;tee-and-exposition&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Tee and exposition&lt;/h1&gt;
&lt;p&gt;magrittr이 지원하는 기억할 만한 두 개의 파이프라인 명령은 Tee와 Exposition이다.&lt;/p&gt;
&lt;div id=&#34;tee&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tee&lt;/h2&gt;
&lt;p&gt;Tee는 파이프라인을 끊어야 하는 상황을 수습해준다. &lt;code&gt;%T&amp;gt;%&lt;/code&gt;의 lhs는 일단 &lt;code&gt;plot&lt;/code&gt;으로 던져진다. 하지만, plot 객체는 다시 계산에 동원될 수 없다. 이 녀석은 그림 객체이므로 계산에 동원되는 것 자체가 말이 안된다. 이럴 경우 파이프가 끊어질 수 밖에 없다. &lt;code&gt;%T&amp;gt;%&lt;/code&gt;의 경우는 이러한 side effect(그림 등등)가 발생하는 발생한 후에 다시 원래 lhs로 복귀할 수 있게 해준다. &lt;code&gt;plot&lt;/code&gt; 뒤에 붙은 파이프라인의 경우 &lt;code&gt;%T&amp;gt;%&lt;/code&gt;앞의 lhs를 인자로 받는다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rnorm(200) %&amp;gt;%
matrix(ncol = 2) %T&amp;gt;%
plot %&amp;gt;% # plot usually does not return anything.
colSums&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/note/2017-11-15-magrittr_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;## [1]  5.095882 -5.053791&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;exposition&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Exposition&lt;/h2&gt;
&lt;p&gt;Exposition &lt;code&gt;%$%&lt;/code&gt;은 쉽게 말해 native R의 &lt;code&gt;with&lt;/code&gt; 명령어가 파이프 속에 들어 있다고 생각하면 된다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;%
  subset(Sepal.Length &amp;gt; mean(Sepal.Length)) %$%
  cor(Sepal.Length, Sepal.Width)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.3361992&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;첫번째 파이프까지 끝나고 나면 &lt;code&gt;subset&lt;/code&gt;을 통해 data.frame이 생성된다. 이 데이터 프레임 내의 두 변수의 상관계수를 찾고자 한다. 위의 예를 그냥 통상적인 &lt;code&gt;%&amp;gt;%&lt;/code&gt;으로만 쓰고 싶다면 cor에 아래와 같이 써주면 된다.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;iris %&amp;gt;%
  subset(Sepal.Length &amp;gt; mean(Sepal.Length)) %&amp;gt;%
  { cor(.$Sepal.Length, .$Sepal.Width) }&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.3361992&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;%$%&lt;/code&gt;는 위의 작업을 보다 직관적인 형태로 수행한다.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;tidyverse가 magrittr을 포괄하고 있는데 왜 두 번 로딩을 할까? 만일 앞서의 &lt;code&gt;install_github&lt;/code&gt;를 통해서 최신 패키지를 설치했다면 이 녀석은 tidyverse에 통합된 녀석과 다를 수도 있다. 최신 기능을 활용하기 위해서는 이렇게 순서를 다르게 패키지를 로딩하면 된다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;출처는 &lt;a href=&#34;https://stackoverflow.com/questions/44528173/using-table-in-dplyr-chain&#34;&gt;여기&lt;/a&gt;다.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Adding bigfoot.js to Hugo</title>
      <link>/note/2017/11/01/adding-bigfoot.js-to-hugo/</link>
      <pubDate>Wed, 01 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/11/01/adding-bigfoot.js-to-hugo/</guid>
      <description>&lt;div id=&#34;bigfoot&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;BIGFOOT!&lt;/h1&gt;
&lt;p&gt;웹서핑을 하다가 이 녀석을 보고야 말았다, &lt;a href=&#34;http://bigfootjs.com/&#34;&gt;bigfoot.js&lt;/a&gt;. 웹 문서가 고도화된 지금 인터넷으로 노출하는 문서에서 표현의 방법으로 답답함을 느끼는 일은 거의 없을 터다. 표, 수식, 그림 등을 동원해 소통할 때 pdf 등의 프린트 기반 문서들과 비교해 보다 기발하고 뛰어난 사례들도 많다. 당장 이 문서가 작성되고 있는 markdown이 그 대표 사례다.&lt;/p&gt;
&lt;p&gt;어쨌든 왠만한 것들이 쉽게 된다는 걸 알게 되면, 작은 차이들이 눈에 들어오기 마련이다. 각주 처리만 좀 더 ‘멋지게’ 되면 좋겠는데, 싶었다. 마치 등이 살짝 가려운 데 긁지 못하는 격이랄까. 이때 &lt;code&gt;bigfoot.js&lt;/code&gt;를 보게된 것이다! 각주를 누르면 버블로 해당 텍스트가 그 자리에 등장한다. 이거야말로 인터랙티브 문서가 지닌 장점이 아닌가!&lt;/p&gt;
&lt;p&gt;그래서 바로 검색 들어 갔다. 우선, 필요한 요소를 챙겨보자.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;bigfoot.js&lt;/code&gt;를 구현하는 자바 스크립트&lt;/li&gt;
&lt;li&gt;해당 자바스크립트를 이 공간이 사용하고 있는 Hugo framework에 배치하기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 두가지만 얼추 해결되면 될 듯 싶었다. 어제 밤에 딱 10분 검색해서 찾아냈다.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-installsource&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How to install&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;원래 &lt;code&gt;bigfoot.js&lt;/code&gt;는 ’점 세개’가 나오는 형태여서 숫자로 표기되는 전통적인 각주와는 어울리지 않는다. &lt;code&gt;bigfoot.js&lt;/code&gt;는 보다 간략한 형태의 &lt;code&gt;barefoot.min.js&lt;/code&gt;도 제공한다. 이 녀석을 붙여보기로 하자.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/philgruneich/barefoot&#34;&gt;barefoot github&lt;/a&gt;에서 &lt;code&gt;barefoot.min.js&lt;/code&gt;, &lt;code&gt;barefoot.min.css&lt;/code&gt;를 다운 받는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;barefoot.min.js&lt;/code&gt;을 &lt;code&gt;static/js&lt;/code&gt;에 넣어준다. 혹시 &lt;code&gt;static&lt;/code&gt; 디렉토리 안에 &lt;code&gt;js&lt;/code&gt;가 없다면 만들면 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;barefoot.min.css&lt;/code&gt;을 &lt;code&gt;static/css&lt;/code&gt;에 넣어준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;themes/[YOUR_THEME_NAME]/layouts/partials/footer.html&lt;/code&gt;을 열어서 아래 코드를 적절한 위치에 삽입한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;/css/barefoot.min.css&amp;quot;&amp;gt;

&amp;lt;script src=&amp;quot;/js/barefoot.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
  lf = new BareFoot();
  lf.init();
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;how-to-use&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How to use&lt;/h1&gt;
&lt;p&gt;그냥 markdown에 각주 쓰듯이 쓰면 되겠다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;This is barefoot![^baref]

[^baref]: 이것은 베어풋으로 붙인 각주입니다! &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is barefoot!&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;부끄럽지만 몹시 뿌듯하고 기뻤다! ㅎ&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;이 내용의 출처는 &lt;a href=&#34;http://egeiro.net/post/barefoot-notes/&#34;&gt;여기&lt;/a&gt;다.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;이것은 베어풋으로 붙인 각주입니다!&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>My Stupid Git Experience, part 1</title>
      <link>/note/2017/10/20/my-stupid-git-experience-part-1/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/10/20/my-stupid-git-experience-part-1/</guid>
      <description>&lt;div id=&#34;disclaimer&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Disclaimer&lt;/h1&gt;
&lt;p&gt;이 문서는 &lt;code&gt;git&lt;/code&gt;을 다루면서 저질렀던 개인적을 실수를 모아 놓은 것이다. 아마도 문서 자체가 조금씩 진화할 것이므로 어떤 시점에서 보신다면 몹시 허접할 수 있도 있겠다. git에 대해서 잘 아는 분들은 패스하시라. 일단, &lt;code&gt;branch&lt;/code&gt;를 심각하게 쓰지 않는다면 여기 나온 정도로 충분할 것 같다.&lt;/p&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-structure&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic structure&lt;/h1&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/dr_structure.png&#34; /&gt;

&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;working dir&lt;/code&gt;: local의 작업디렉토리&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index&lt;/code&gt;: staging area. 커밋될 파일들을 올려 두는 공간&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD&lt;/code&gt;: 마지막으로 커밋이 이루어진 branch&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/git-operations.png&#34; /&gt;

&lt;/div&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;div id=&#34;basic-command&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Basic command&lt;/h1&gt;
&lt;div id=&#34;initiation-in-local&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Initiation in local&lt;/h2&gt;
&lt;p&gt;로컬머신에서 git을 개시하는 방법부터 알아보자. git으로 관리하고 싶은 directory에서 아래와 같은 명령어를 쳐 준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; echo &amp;quot;# YOUR_README_NAME&amp;quot; &amp;gt;&amp;gt; README.md 
&amp;gt; git init
&amp;gt; git add README.md 
&amp;gt; git commit -m &amp;quot;YOUR_COMMIT_MESSAGE(e.g. first commit)&amp;quot;
&amp;gt; git remote add origin &amp;lt;&amp;lt;https://YOUR_REMOTE_GIT_URL&amp;gt;&amp;gt;
&amp;gt; git push -u origin master &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;https://YOUR_REMOTE_GIT_URL&amp;gt;&amp;gt;&lt;/code&gt;: 외부 리포가 적절하게 세팅이 되어 있어야 한다. github를 쓴다면, readme 없이 새 repository를 터주는 작업 만으로 끝이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo...&lt;/code&gt;: “# YOUR_README_NAME” 내용을 &lt;code&gt;README.md&lt;/code&gt;로 생성한 후&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git init&lt;/code&gt;: 해당 디렉토리에 git을 개시한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git remote add&lt;/code&gt;: git의 remote 저장소를 &lt;code&gt;origin&lt;/code&gt;이라는 이름으로 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push -u origin master&lt;/code&gt;: &lt;code&gt;-u&lt;/code&gt;는 업스트림 브랜치를 master로 기본설정해준다. 이후 &lt;code&gt;git push&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;은 자동으로 &lt;code&gt;origin &amp;lt;-&amp;gt; master&lt;/code&gt;가 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;add-commit-push&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;add&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git status  
&amp;gt; git add .

#or

&amp;gt; git add -u
&amp;gt; git commit -m &amp;quot;YOUR_COMMENT&amp;quot;
&amp;gt; git push &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;git 운용의 기본적인 흐름 혹은 기본 명령어 셋&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt;만 명령하면 되는 것은 앞서 &lt;code&gt;git push -u origin master&lt;/code&gt; origin master로 local과 remote repository의 upstream을 정해두었기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;in-depth-command&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;In-depth command&lt;/h1&gt;
&lt;div id=&#34;remote&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;remote&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git remote origin 
&amp;gt; git remote -v &lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git status  
&amp;gt; git add .
&amp;gt; git commit -m &amp;quot;YOUR_COMMENT&amp;quot;
&amp;gt; git push &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git remote&lt;/code&gt; : remote로 어떤 대상이 설정되어 있는지 볼 수 있다. &lt;code&gt;git remote -v&lt;/code&gt;: remote의 구체적인 내용을 조회해볼 수 있다.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;pull&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;pull&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pull&lt;/code&gt;: &lt;code&gt;fetch&lt;/code&gt;(가져오기)와 &lt;code&gt;merge&lt;/code&gt;(병합하기)를 동시에 구현
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fetch&lt;/code&gt;: repository의 내용을 가져와 &lt;code&gt;FETCH_HEAD&lt;/code&gt;라는 local branch에 임시로 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;: &lt;code&gt;fetch&lt;/code&gt; 불러온 데이터를 원래 흐름과 병합&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;origin과 master에서 모두 변경 사항이 있을 경우는 둘에 충돌이 일어날 수 밖에 없다. 이런 경우 이 충돌을 해결해줘야 &lt;code&gt;push&lt;/code&gt;가 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git pull --rebase&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;깔끔한 이력 관리를 위해서는 rebase를 활용해서 pull을 해주면 좋다. rebase를 해주면 별도의 브랜치를 만들지 않겠다는 의도를 분명히 하는 것이고, 이에 따라서 log가 깔끔하고 단순해진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;commit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;commit&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit -m &amp;quot;&amp;lt;&amp;lt;YOUR_MESSAGE&amp;gt;&amp;gt;&amp;quot;&lt;/code&gt;: 기본적인 문법&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;-commit-push---&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;이전 &lt;code&gt;commit-push&lt;/code&gt;된 버전을 수정하고 싶다면&lt;/h3&gt;
&lt;p&gt;뭔가를 수정했다. 하지만 새로운 commit을 만들고 싶지 않다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git commit --amend --no-edit&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--amend --no-edit&lt;/code&gt;: 전에 commit message를 그대로 쓰고 commit한다.
&lt;ul&gt;
&lt;li&gt;이대로 push를 할 수 없다. 앞서 push된 버전과 현 수정된 버전이 같은 commit인데 내용은 다르다. 즉, SHA-1이 다르다. 이때 강제로 &lt;code&gt;push&lt;/code&gt;를 하고 싶다면 아래와 같이 한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git push -f [origin] [master]&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt;: commit을 새로 만든 것이 아니기 때문에, 그대로 push를 하게 되면 origin과 맞지 않게 된다. 강제로 push를 해서 맞춰주는 명령어다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;concept-of-branch&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Concept of &lt;code&gt;branch&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;이 꼭지는 &lt;a href=&#34;https://backlog.com/git-tutorial/kr/&#34;&gt;backlog.com&lt;/a&gt;을 많이 참고했습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;브랜치란 현재 &lt;code&gt;HEAD&lt;/code&gt; 스냅샷에 대해서 다른 이름을 부여해주는 작업이다. 일단, 아무런 변경이 없는 이상 브랜치는 분기되지 않고 노드에 함께 머물러 있다. 일단 기본적인 명령어는 아래와 같다.&lt;/p&gt;
&lt;div id=&#34;basic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Basic&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git branch &amp;lt;BRANCH_NAME&amp;gt;
&amp;gt; git checkout
&amp;gt; git checkout -b &amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git branch&lt;/code&gt;: 브랜치를 조회하거나, &lt;code&gt;&amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;을 붙여 브랜치를 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;checkout&lt;/code&gt;이란 다른 브랜치로 빠져나가는 것을 의미한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt;: 브랜치를 만들면서 체크아웃을 하기 위해서는 이 옵션을 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git merge &amp;lt;COMMIT_NAME&amp;gt; 
&amp;gt; git branch -d &amp;lt;BRANCH_NAME&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;: 커밋된 다른 지점과 현재 HEAD의 브랜치를 병합한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;: 브랜치를 삭제하기 위해서 사용하는 명령어&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;in-practice&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;In practice&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git branch issue2
&amp;gt; git branch issue3
&amp;gt; git checkout issue2
  Switched to branch &amp;#39;issue2&amp;#39;
&amp;gt; git branch
* issue2
  issue3
  master&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 명령어를 수행한 상태의 그림이다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/branch1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;issue2의 어떤 내용을 수정했다고 하자.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/branch2.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git checkout issue3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;issue3 branch에서 어떤 내용을 또 수정했다고 하자.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/branch3.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;그리고 master를 issue2와 병합하면 다음의 그림과 같은 상태로 이해하면 된다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/conflict.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conflict&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Conflict&lt;/h2&gt;
&lt;p&gt;위의 그림에서 아래의 명령어를 수행한다고 하자.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git checkout master
&amp;gt; git merge issue3&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;이때 어떤 파일에 대해서 &lt;code&gt;HEAD&lt;/code&gt;의 master의 내용과 issue3의 내용이 서로 다른 부분이 있다고 하자.&lt;/li&gt;
&lt;li&gt;병합이 무리 없이 가능하다면 그대로 병합된다. 즉, A와 B가 있을 떄 B가 A의 내용을 포함하고 있다면, 병합이 가능하다.&lt;/li&gt;
&lt;li&gt;파일 자체가 다른 경우는 인간의 판단이 필요하다. 해당 파일을 열면 아래와 같이 표현되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;원숭이도 이해할 수 있는 Git 명령어
add: 변경 사항을 만들어서 인덱스에 등록해보기
&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD
commit: 인덱스의 상태를 기록하기
=======
pull: 원격 저장소의 내용을 가져오기
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; issue3&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD&lt;/code&gt;는 &lt;code&gt;====&lt;/code&gt;까지 HEAD의 부분이고, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; issue3&lt;/code&gt;의 부분이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;what-is-rebase&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What is &lt;code&gt;rebase&lt;/code&gt;&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;개념&lt;/h2&gt;
&lt;p&gt;특정한 브랜치를 다른 브랜치로 합친 후에 이전 브랜치는 없애고 싶을 때, 한번에 처리하는 명령어가 rebase다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;리베이스는 병합될 브랜치에서 시작!&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;원래 상태는 HEAD를 master로 하고 브랜치는 다음과 같이 3가지다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git checkout issue3
&amp;gt; git rebase master &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;issue3로 체크아웃을 한 뒤에 해당 브랜치를 master로 rebase한다. 만일 두 노드 사이에 충돌이 없다면 rebase가 되곘지만, 충돌이 있을 경우에는 해당 파일을 수정해줘야 한다. 수정 후 아래와 같이 rebase한다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_2.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git add myfile.txt 
&amp;gt; git rebase --continue &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_3.png&#34; /&gt;

&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git checkout master 
&amp;gt; git merge issue3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;master&lt;/code&gt;로 체크아웃한 이후에 issue3 merge하면 아래와 같이 가지가 정리된다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;img/rebase_4.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;also&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Also&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;merge&lt;/code&gt;와 &lt;code&gt;rebase&lt;/code&gt;의 개념적인 차이에 대해서는 &lt;a href=&#34;https://backlog.com/git-tutorial/kr/stepup/stepup1_4.html&#34;&gt;Link&lt;/a&gt;를 참고&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;case-by-case&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Case by case&lt;/h1&gt;
&lt;div id=&#34;github---local---&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Github의 내용을 강제로 local로 덮어쓰고 싶을 때&lt;/h2&gt;
&lt;p&gt;그냥 지우고 다시 clone을 할 수도 있다. 하지만 아래 같이 해주면 불필요한 동기화를 막을 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git fetch --all
&amp;gt; git reset --hard origin/master
&amp;gt; git pull origin master&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;local----github---&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;local에 있는 내용을 강제로 github으로 보내고 싶을 때&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git pull --rebase
&amp;gt; git push
&amp;gt; git stash pop&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;miscellaneous&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Miscellaneous&lt;/h1&gt;
&lt;div id=&#34;gitignore&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;.gitignore&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;vim으로 만들 수도 있다. 물론, 흔한 txt editor로 만들어도 무방하다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim .gitignore &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;vim 화면 위쪽에 입력하려면 i(insert)를 치고, 제외할 타잎을 넣는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;*.Rhistory 
*.RData &lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;ESC를 치면 화면 아래 command 창으로 이동한다. :qw(quit &amp;amp; write)를 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;homework-rule-of-thumb&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Homework &amp;amp; Rule of Thumb&lt;/h1&gt;
&lt;p&gt;앞으로 더 알아야 하지만 지금은 그냥 넘어갈 내용들이다.&lt;/p&gt;
&lt;div id=&#34;log&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;log&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;여러가지 옵션이 있고 활용하면 좋을 듯 하지만, 당분간 나에게는 히스토리를 그냥 순서대로 보여주는 아래 명령어 정도면 충분할 듯 싶다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git log --pretty=oneline
&amp;gt; git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git log --pretty=oneline&lt;/code&gt;: oneline으로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;&lt;/code&gt;: 포매팅한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;log&lt;/code&gt;에 대해서는 다음을 참고: &lt;a href=&#34;https://git-scm.com/book/ko/v1/Git%EC%9D%98-%EA%B8%B0%EC%B4%88-%EC%BB%A4%EB%B0%8B-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC-%EC%A1%B0%ED%9A%8C%ED%95%98%EA%B8%B0&#34;&gt;링크&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;git-github--&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Git과 github 계정의 연동&lt;/h2&gt;
&lt;p&gt;원래 local setting이 없는 머신에서 최초로 git 작업을 하면 아래의 사항을 처리해야 한다.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;이름과 이메일 어카운트 세팅&lt;/li&gt;
&lt;li&gt;repo 접근 권한&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git config --global user.email &amp;quot;##USER EMAIL##&amp;quot;
&amp;gt; git config --global user.name &amp;quot;##USER NAME##&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;repo로 날리게 되면 username과 password를 묻게 된다. 매번 하기 귀찮다면 다음과 같이 처리해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; git config --global credential.helper cache
&amp;gt; git config --global push.default simple&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;other-link&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other link&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://meetup.toast.com/posts/116&#34; class=&#34;uri&#34;&gt;http://meetup.toast.com/posts/116&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>All dots are not created same...</title>
      <link>/note/2017/10/18/all-dots-are-not-created-same.../</link>
      <pubDate>Wed, 18 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/10/18/all-dots-are-not-created-same.../</guid>
      <description>&lt;div id=&#34;cdots-ldots-and-so-on&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;code&gt;\cdots&lt;/code&gt;, &lt;code&gt;\ldots&lt;/code&gt;, and so on&lt;/h1&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\mathrm \LaTeX\)&lt;/span&gt;으로 조판하는 분들에게는 때때로 아리송한 사항들이 몇 개 있다. 작정하고 알아보기에는 사소하고 그렇다고 넘어가기엔 찜찜한, 뭐 그런 것들이다. 요즘은 무늬나마 공부하는 사람일 때 만큼 &lt;span class=&#34;math inline&#34;&gt;\(\mathrm \LaTeX\)&lt;/span&gt;을 쓰지 않는다. 그래도 가끔 쓰기는 해서일까? 이런 사소한 내용에 더 큰 궁금증을 느낄 때가 많다.&lt;/p&gt;
&lt;p&gt;문득, &lt;code&gt;\cdots&lt;/code&gt;(&lt;span class=&#34;math inline&#34;&gt;\(\cdots\)&lt;/span&gt;)과 &lt;code&gt;\ldots&lt;/code&gt;(&lt;span class=&#34;math inline&#34;&gt;\(\ldots\)&lt;/span&gt;)은 어떻게 다르지, 라는 질문이 떠올랐다. 분명, 수학 기호의 일부이기 때문에 다르기는 다를텐데 말이다. 천조국수학회(AMS)에서 관리하는 수학 조판 패키지인 &lt;code&gt;amsmath&lt;/code&gt; 패키지의 &lt;a href=&#34;http://www.tug.org/teTeX/tetex-texmfdist/doc/latex/amsmath/amsldoc.pdf&#34;&gt;이용자 매뉴얼&lt;/a&gt;에 따르면 ’점 세개’로 표기되는 기호들은 명령어 차원에서 구분된다. 즉, 외견상 같은 모양을 하고 있더라도 구분해서 쓰라는 취지인 셈이다. AMS 패키지 매뉴얼은 현재 2.0이 최신 버전이고 만들어진 날짜는 2002년 2월 25일이다… (그간 이 매뉴얼을 꼼꼼하게 볼 생각을 하지 않았다니 ㅠㅠ)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;according-to-ams-package-guide&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;According to AMS package guide&lt;/h1&gt;
&lt;p&gt;가이드 12쪽에 보면 ’점 세개’는 아래와 같이 다섯가지로 구분되어 있다.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;\dotsc&lt;/code&gt; for “dots with commas”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsb&lt;/code&gt; for “dots with binary operators / relations”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsm&lt;/code&gt; for “multiplication dots”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsi&lt;/code&gt; for “dots with integrals”&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotso&lt;/code&gt; for “other dots” (none of the above)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AMS 구분을 보고 무릎을 ‘탁’ 쳤다. 바로 이거야!&lt;/p&gt;
&lt;p&gt;직접 조판해보자.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;\dotsc&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(A_1, A_2, \dotsc\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsb&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(A_1 + A_2 + \dotsb\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsm&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(A_1 A_2 \dotsm\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\dotsi&lt;/code&gt;: &lt;span class=&#34;math inline&#34;&gt;\(\begin{aligned}  \int_{A_1} \int_{A_2} \dotsi  \end{aligned}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;뭐 다 비슷비슷해 보일 수 있으나, 참으로 감동이 아닌가!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Data Talk</title>
      <link>/note/2017/09/19/data-talk/</link>
      <pubDate>Tue, 19 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/09/19/data-talk/</guid>
      <description>&lt;div id=&#34;prologue&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Prologue&lt;/h1&gt;
&lt;p&gt;개인적이든 직업적인 이유든 데이터를 볼 일이 많습니다. 인상적으로 본 데이터를 소개하는 꼭지를 한번 만들어 봅니다. 제가 여기저기서 본 것들을 가져옵니다. 독창성 같은 건 기대하지 마시기를… 아울러 업데이트도 기분 내킬 때!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;alchol-vs-suicide&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Alchol vs Suicide&lt;/h1&gt;
&lt;p&gt;인과관계는 아니니까, 그렇구나 하고 말지요.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://i.redd.it/15ps6g0lupmz.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;how-death-has-changed-over-100-years-in-britain&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How death has changed over 100 years in Britain&lt;/h1&gt;
&lt;p&gt;엄청난 비주얼라이제이션입니다. 일종의 동영상이라고 할 수 있을텐데, 공중보건의 주요한 사건과 죽음의 양상을 잘 이야기해주고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.theguardian.com/lifeandstyle/ng-interactive/2017/sep/18/how-death-has-changed-over-100-years-in-britain&#34;&gt;Guardian&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;years-of-economic-history-in-one-chart&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2,000 Years of Economic History in One Chart&lt;/h1&gt;
&lt;p&gt;혹자의 이야기처럼, 중국은 “열강”이 아닌 적이 별로 없었던 나라입니다. 요즘이 정상으로 돌아오고 있는 국면일 수도 있겠지요.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;http://2oqz471sa19h3vbwa53m33yj.wpengine.netdna-cdn.com/wp-content/uploads/2017/09/share-of-gdp-history1070.jpg&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;&lt;a href=&#34;http://www.visualcapitalist.com/2000-years-economic-history-one-chart&#34;&gt;Visual Capitalist&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;google-public-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Google Public Data&lt;/h1&gt;
&lt;p&gt;아직은 World Bank 데이터 밖에 없는 것 같습니다만, 구글이 하는 일이니 소리소문 없이 좋아지리라 생각합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.google.com/publicdata/explore?ds=d5bncppjof8f9_&amp;amp;met_y=sp_pop_totl&amp;amp;hl=en&amp;amp;dl=en&#34;&gt;Google Public Data&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;baltimore-neighborhood-health&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Baltimore Neighborhood Health&lt;/h1&gt;
&lt;p&gt;훌륭합니다! 제가 볼티모어 거주자가 아니라서 보는 감상의 깊이가 다릅니다. 한국 도시들도 이런 거 만들어주세요!&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://data.baltimoresun.com/news/neighborhood-health/&#34;&gt;Baltimore Sun&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;rise-of-streaming&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Rise of Streaming&lt;/h1&gt;
&lt;p&gt;올해 에미상에서 “Handmaid’s Tale”의 작품상 수상이 화제입니다. 에미 후보작들의 변화는 가정용 엔터테인먼트의 변화를 잘 보여줍니다.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;https://i.redd.it/8fu135v7comz.png&#34; /&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Another Note on A blogdown Tutorial</title>
      <link>/note/2017/06/14/another-note/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/06/14/another-note/</guid>
      <description>&lt;p&gt;I just discovered &lt;a href=&#34;https://apreshill.rbind.io/post/up-and-running-with-blogdown/&#34;&gt;an awesome tutorial&lt;/a&gt; on &lt;strong&gt;blogdown&lt;/strong&gt; written by Alison. I have to admit this is &lt;em&gt;the&lt;/em&gt; best &lt;strong&gt;blogdown&lt;/strong&gt; tutorial I have seen so far.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://apreshill.rbind.io/img/posts/2017-06-12-up-and-running-with-blogdown/blogdown-signpost-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Quick Note on Two Beautiful Websites</title>
      <link>/note/2017/06/13/a-quick-note/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/note/2017/06/13/a-quick-note/</guid>
      <description>&lt;p&gt;To me, the two most impressive websites based on &lt;strong&gt;blogdown&lt;/strong&gt; are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://robjhyndman.com&#34;&gt;Rob J Hyndman&lt;/a&gt;&amp;rsquo;s personal website.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://livefreeordichotomize.com&#34;&gt;Live Free or Dichotomize&lt;/a&gt; by Lucy and Nick &lt;em&gt;et al&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I&amp;rsquo;m sure there will be more.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>